I"&3<h2 id="0-들어가며">0. 들어가며</h2>

<p><strong>Python을 이용한 알고리즘과 자료구조</strong>에 대해 공부한 내용을 바탕으로 간단히 포스팅할 계획입니다. <a href="https://spartacodingclub.kr/">스파르타 코딩클럽</a>의 알고보면 알기쉬운 알고리즘 강의를 수강하고 강의안을 참고하여 정리하였습니다.</p>

<p>알고리즘의 성능은 어떻게, 어떤 지표로 표현할 수 있을까요? 이번 포스트에서는 <strong>알고리즘의 복잡도와 이를 표기하는 빅오 표기법</strong>에 대해 살펴보도록 하겠습니다.</p>

<hr />

<p>데이터마이닝 알고리즘 구현 과제에 교수님께서 학생들이 과도하게 루프문을 사용하는 것을 방지하는 차원에서, <strong>for문을 금지</strong>하신 적이 있었습니다. output이야 어떻게든 계산되어 출력하게 만들 수 있지만.. for문 없이 구현하려니 적잖이 애를 먹었습니다. 행렬 곱, map 등 갖은 방법을 동원해서 과제를 해결했었는데 컴퓨팅 타임을 비교하니 당연히 for문을 안 쓴 알고리즘이 훨씬 빠르고 깔끔했습니다. 그 때 효율적인 알고리즘에 대해 처음으로 깊게 고민했던 것 같습니다. 시간 복잡도를 통해서 루프문이 미치는 연산량의 차이에 대해 알아보겠습니다.</p>

<h2 id="1-시간-복잡도">1. 시간 복잡도</h2>

<h3 id="시간-복잡도란">시간 복잡도란?</h3>

<p>알고리즘의 복잡도는 시간 복잡도와 공간 복잡도가 있습니다.</p>

<p><strong>시간 복잡도</strong>란 input에서 output이 출력되는, 즉 문제를 해결하는 데 걸리는 시간과의 상관관계로 입력된 크기($N$)에 따라 실행되는 연산의 수로 나타냅니다. 입력값이 늘어났을 때 문제를 해결하는 데 걸리는 시간은 몇 배로 늘어나는지를 보는 것입니다. 당연히 입력값이 늘어나도 걸리는 시간이 덜 늘어나는 알고리즘이 좋은 알고리즘입니다.</p>

<p><strong>공간 복잡도</strong>는 알고리즘이 실행될 때 사용하는 메모리의 양을 나타내는데, 요즘은 메모리의 발전으로 공간 복잡도의 중요도가 낮아졌습니다.</p>

<p>아래 array에 최대값을 찾는 예제를 통해 시간 복잡도를 구체적으로 살펴보겠습니다.</p>

<h4 id="방법1">방법1.</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">find_max_num</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>		<span class="c1"># array의 길이(N)만큼 아래 연산이 실행
</span>        <span class="k">for</span> <span class="n">compare_num</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>		<span class="c1"># array의 길이(N)만큼 아래 연산이 실행
</span>            <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">compare_num</span><span class="p">:</span>		<span class="c1"># 비교 연산 1번 실행
</span>                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">num</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">find_max_num</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>위에 연산된 것들을 더해보면, array의 길이를 N이라고 했을 때 $N(array의 길이) \times N(array의 길이) \times 1$ 의 시간이 필요합니다. 따라서 방법1의 시간 복잡도는</p>

<p>$$
N \times N
$$</p>

<p>입니다.</p>

<h4 id="방법2">방법2.</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">find_max_num</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">max_num</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>		<span class="c1"># 연산 1번 실행
</span>    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>		<span class="c1"># array의 길이(N)만큼 아래 연산이 실행
</span>        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">max_num</span><span class="p">:</span>		<span class="c1"># 비교 연산 1번 실행
</span>            <span class="n">max_num</span> <span class="o">=</span> <span class="n">num</span>		<span class="c1"># 대입 연산 1번 실행
</span>    <span class="k">return</span> <span class="n">max_num</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">find_max_num</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>
<p>위에 연산된 것들을 더해보면, array의 길이를 N이라고 했을 때 $ 1 + N(array의 길이) \times (비교 연산 1번 + 대입 연산 1번) $ 의 시간이 필요합니다. 따라서 방법2의 시간 복잡도는</p>

<p>$$
1 + 2 \times N
$$</p>

<p>입니다.</p>

<h4 id="방법1-vs--방법2">방법1. vs.  방법2.</h4>

<p>두 방법의 시간 복잡도를 비교해보겠습니다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">$N$의 크기</th>
      <th style="text-align: right">방법1. $N^2$</th>
      <th style="text-align: right">방법2. $2N+1$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: right">1</td>
      <td style="text-align: right">3</td>
    </tr>
    <tr>
      <td style="text-align: left">10</td>
      <td style="text-align: right">100</td>
      <td style="text-align: right">21</td>
    </tr>
    <tr>
      <td style="text-align: left">100</td>
      <td style="text-align: right">10000</td>
      <td style="text-align: right">201</td>
    </tr>
    <tr>
      <td style="text-align: left">1000</td>
      <td style="text-align: right">1000000</td>
      <td style="text-align: right">2001</td>
    </tr>
    <tr>
      <td style="text-align: left">10000</td>
      <td style="text-align: right">100000000</td>
      <td style="text-align: right">20001</td>
    </tr>
  </tbody>
</table>

<p>N의 크기가 커질 수록 $N^2$의 숫자가 훨씬 더 큰 차이를 보입니다. 또한 $2N+1$에 상수는 미미한 숫자 차이이므로 무시할만 한 정도이므로 $2N+1$의 연산량은 가장 큰 영향을 미치는 N의 텀인 $2N$만 보면 됩니다.</p>

<h2 id="2-점근-표기법">2. 점근 표기법</h2>

<p>점근 표기법(asymptotic notation)은 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법으로, 알고리즘의 성능을 수학적으로 표기하는 방법으로 쓰입니다.</p>

<ul>
  <li><strong>빅오(Big-O) 표기법</strong>은 최악의 성능이 나올 때 어느 정도의 연산량이 걸릴것인지에 대해 표기합니다.</li>
  <li><strong>빅오메가(Big-Ω) 표기법</strong>은 최선의 성능이 나올 때 어느 정도의 연산량이 걸릴것인지에 대해 표기합니다.</li>
</ul>

<p>예시를 들어 살펴보겠습니다. 배열을 돌면서 배열의 원소가 찾고자하는 숫자와 같은지 비교하는 아래 알고리즘이 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">is_number_exist</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>		<span class="c1"># array의 길이(N)만큼 아래 연산이 실행
</span>        <span class="k">if</span> <span class="n">number</span> <span class="o">==</span> <span class="n">element</span><span class="p">:</span>		<span class="c1"># 비교 연산 1번 실행
</span>            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">is_number_exist</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>위에서 연산된 것들을 더해보면, 총 $ N \times 1 $의 시간 복잡도를 가집니다. 그런데 여기서 모든 경우에 $N$ 만큼의 시간이 걸릴까요?</p>

<p>만약 3과 같은 숫자를 찾고 있다면 1번만에 찾을 것이고, 4를 찾는다면 6번만에 찾을 것입니다. 최선의 성능일 때의 연산량은 1, 최악의 성능일 때의 연산량은 6입니다.</p>

<p>따라서 빅오 표기법으로 $O(N)$, 빅오메가 표기법으로 표시하면 $\Omega (1)$ 의 시간 복잡도를 가지고 있습니다.</p>

<p>이처럼 알고리즘의 성능은 항상 동일한 게 아니라 입력값에 따라 달라질 수 있습니다. <strong>그러나 알고리즘에서는 빅오 표기법으로 분석합니다.</strong> 왜냐면 대부분 최악의 경우에 시간이 얼마나 소요될지를 대비해야하기 때문입니다.</p>

<p>앞서 최대값을 구하는 알고리즘 방법1과 방법2의 시간복잡도는 Big-O 표기법으로 아래처럼 나타낼 수 있습니다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">구분</th>
      <th style="text-align: center">방법1.</th>
      <th style="text-align: center">방법2.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">시간 복잡도</td>
      <td style="text-align: center">$N^2$</td>
      <td style="text-align: center">$2N+1$</td>
    </tr>
    <tr>
      <td style="text-align: center">Big-O 표기법</td>
      <td style="text-align: center">$O(N^2)$</td>
      <td style="text-align: center">$O(N)$</td>
    </tr>
  </tbody>
</table>

<h3 id="시간-복잡도-그래프">시간 복잡도 그래프</h3>

<p>빅오 복잡도는 대표적으로 아래 그래프와 같은 관계를 가집니다.</p>

<p><img src="/assets/images/big-o-complexity.png" width="80%" /></p>
<center> <small> 참고: https://www.bigocheatsheet.com </small> </center>
<p><br /></p>

<p>N이 커질수록 엄청나게 큰 연산량의 차이가 생깁니다. $O(N^2)$와 $O(N)$의 엄청난 차이도 확인할 수 있습니다.</p>

<hr />

<p>효율적인 알고리즘을 어떻게 측정하는지에 대해서 살펴보았습니다. 단순히 <em>‘다중루프가 연산량이 많다’</em> 라고는 알았지만 직접 연산량을 구하고 빅오 표기법으로 계산해보니 어떻게 구현하는 알고리즘이 효율적인 알고리즘인지 확 느껴지네요.</p>

<p>알고리즘의 복잡도는 루프문 뿐만 아니라 정렬과 자료구조에서도 차이를 보이니 자세한 내용은 참고 사이트에서 확인하시면 될 것 같습니다.</p>

<h2 id="reference">Reference</h2>
<ul>
  <li><a href="https://www.bigocheatsheet.com">Big-O Cheat Sheet</a></li>
</ul>

:ET